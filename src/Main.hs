{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
module Main where
import Text.ParserCombinators.Parsec
import System.Posix.Files(fileExist)
import Data.Time.Clock
import Data.Time.LocalTime
import Data.Time.Calendar
import Data.List (sortBy)
import qualified Data.Map as M
import Options.Generic

data VimLogTime = VimLogTime {
    vimLogYear   :: Integer
  , vimLogMonth  :: Int
  , vimLogDay    :: Int
  , vimLogHour   :: Int
  , vimLogMinute :: Int
  , vimLogSecond :: Int
} deriving(Eq, Show)

data VimLogAction    = Create | Open | Write deriving(Eq, Show)
type VimLogGitBranch = String
type VimFileType     = String
data VimLog = VimLog {
    time       :: VimLogTime
  , action     :: VimLogAction
  , editedfile :: FilePath
  , filetype   :: VimFileType
  , gitbranch  :: Maybe VimLogGitBranch
} deriving(Eq, Show)

secondOfDay :: VimLogTime -> Integer
secondOfDay t = let h = toInteger $ vimLogHour   t
                    m = toInteger $ vimLogMinute t
                    s = toInteger $ vimLogSecond t
                 in h * 3600 + m * 60 + s

dateToday :: IO String -- (year, month, day)
dateToday = (map replace . showGregorian . localDay . zonedTimeToLocalTime) <$> getZonedTime
    where replace '-' = '/'
          replace  c   = c

logParser :: Parser VimLog
logParser = VimLog <$> (logTimeParser  <* delimiter)
                   <*> (actionParser   <* delimiter)
                   <*> (filePathParser <* delimiter)
                   <*> (fileTypeParser <* delimiter)
                   <*> branchParser
   where delimiter = char ';'

logTimeParser :: Parser VimLogTime
logTimeParser = VimLogTime <$> (read <$> many1   digit <* char '-') -- year
                           <*> (read <$> count 2 digit <* char '-') -- month
                           <*> (read <$> count 2 digit <* spaces)   -- day
                           <*> (read <$> count 2 digit <* char ':') -- hour
                           <*> (read <$> count 2 digit <* char ':') -- minute
                           <*> (read <$> count 2 digit)             -- second

fileTypeParser :: Parser VimFileType 
fileTypeParser = many1 (noneOf ";") 

actionParser :: Parser VimLogAction
actionParser = (Create <$ string "create")
           <|> (Open   <$ string "open")
           <|> (Write  <$ string "write")

filePathParser :: Parser FilePath
filePathParser = try quotedPath <|> many1 (noneOf ";\n\r")

quotedPath :: Parser FilePath
quotedPath = char '"' *> many1 quotedChar <* char '"'

quotedChar :: Parser Char
quotedChar = try ('"' <$ string "\\\"") <|>  noneOf "\"" <?> "fuck"

branchParser :: Parser (Maybe VimLogGitBranch)
branchParser = (Just <$> filePathParser) <|> (Nothing <$ string "")

eol :: Parser String 
eol = try (string "\n\r")
  <|> try (string "\r\n")
  <|> string "\r"
  <|> string "\n"
  <?> "end of line"

logFileParser :: Parser [VimLog]
logFileParser = logParser `endBy` eol

data CmdOptions = Today { dir :: String, maxInterval :: Maybe Integer }
                | File { file :: String, maxInterval :: Maybe Integer }
                deriving(Generic, Eq, Show)
instance ParseRecord CmdOptions

getInterv :: Maybe Integer -> Integer
getInterv Nothing    = 24 * 3600 -- One day in seconds
getInterv (Just sec) = sec

main :: IO ()
main = do
    opt   <- getRecord "Parse log file generated by https://github.com/Alaya-in-Matrix/vim-activity-log and record how long you have spent on vim"
    today <- dateToday
    (path, interv) <- return $ case opt of
          Today dir  interval -> (dir ++ "/" ++ today ++ ".log", getInterv interval)
          File  file interval -> (file, getInterv interval)
    exist  <- fileExist path
    if not exist
       then putStrLn "No vim action found"
       else do parsed  <- parseFromFile logFileParser path 
               case parsed of
                  Left errMsg -> print errMsg
                  Right val   -> summary interv (sortLog val)

showFtTime :: (VimFileType,Integer) -> String
showFtTime (ft, sec) = ft ++ ": " ++ secToTimeStr sec

secToTimeStr = show . timeToTimeOfDay . secondsToDiffTime

trans2 :: (a->a->b)->(c->a)->c->c->b
trans2 func cvt c1 c2 = func (cvt c1) (cvt c2)

sortLog :: [VimLog]->[VimLog]
sortLog  = sortBy (compare `trans2` (secondOfDay.time))

summary :: Integer -> [VimLog] -> IO ()
summary _ []            = putStrLn "Empty log, no vim action"
summary maxInterval val =
    let records     = filter ((<= maxInterval) . snd) (zipWith genRec val (tail val))
        filetypeMap = M.toList $ foldr updateMap M.empty records
     in do mapM_ (putStrLn . showFtTime) $ sortBy (flip compare `trans2` snd) filetypeMap
           putStrLn ""
           putStrLn $ "Total time spent: " ++ secToTimeStr (sum $ map snd filetypeMap)
           putStrLn "=============================="

updateMap :: (VimFileType, Integer) -> M.Map VimFileType Integer -> M.Map VimFileType Integer
updateMap (ft, tsec) mp = case M.lookup ft mp of
                            Nothing -> M.insert ft tsec mp
                            Just _  -> M.adjust (+tsec) ft mp

genRec :: VimLog -> VimLog -> (VimFileType, Integer)
genRec l1 l2 =
    let t1  = secondOfDay $ time l1
        t2  = secondOfDay $ time l2
     in (filetype l1, t2 - t1)
